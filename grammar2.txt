
single_input -> NEWLINE | simple_stmt | compound_stmt NEWLINE;
async_funcdef -> ASYNC funcdef;
funcdef -> def NAME parameters : suite;
parameters -> ( V1 );
V1 -> typedargslist | e;
typedargslist -> W1 X1 B2 | * D2 X1 B2 | ** tfpdef A2;
W1 -> tfpdef | tfpdef = test;
X1 -> , W1 | , W1 X1;
Y1 -> , Z1 | e;
Z1 -> ** tfpdef A2 -> e;
A2 -> , | e;
B2 -> , C2 | e;
C2 -> * X1 Y1 | ** tfpdef A2 | * tfpdef X1 Y1 | e;
D2 -> tfpdef | e;
tfpdef -> NAME;
varargslist -> vfpdef G2 H2 J2 | * L2 H2 M2 | ** vfpdef A2;
G2 -> = test | e;
H2 -> , vfpdef G2 | , vfpdef G2 H2;
I2 -> ** vfpdef A2 | e;
J2 -> , K2 | e;
K2 -> * L2 H2 M2 | ** vfpdef A2 | e
L2 -> vfpdef | e;
M2 -> , I2 | e;
vfpdef: NAME;
stmt -> simple_stmt | compound_stmt;
simple_stmt -> small_stmt M NEWLINE | small_stmt M ; NEWLINE;
M -> ; small_stmt | ; small_stmt M
small_stmt -> expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt;
expr_stmt -> testlist_star_expr annassign | testlist_star_expr augassign P | testlist_star_expr N;
P -> yield_expr | testlist
N -> = O | = O N
O -> yield_expr | testlist_star_expr
annassign -> : test | : test = test;
testlist_star_expr: R Q | R Q ,;
Q -> , R | , R Q;
R -> test | star_expr;
augassign -> += | -= | *= | @= | /= | %= | &= | |= | ^= | <<= | >>= | **= | //=;
del_stmt -> del exprlist;
pass_stmt -> pass;
flow_stmt -> break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt;
break_stmt -> break;
continue_stmt -> continue;
return_stmt -> return;
yield_stmt -> yield_expr;
raise_stmt -> raise;
import_stmt -> import_name | import_from;
import_name -> import dotted_as_names;
import_from -> from L1 import M1;
J1 -> K1 | K1 J1;
K1 -> . | ...;
L1 -> J1 dotted_name | K1;
M1 -> * | ( import_as_names ) | import_as_names;
import_as_name -> NAME | NAME as NAME;
dotted_as_name -> dotted_name | dotted_name as NAME;
import_as_names -> import_as_name | , import_as_name;
dotted_as_names -> dotted_as_name | , dotted_as_name;
dotted_name -> NAME | . NAME;
global_stmt -> global NAME | global NAME , NAME;
nonlocal_stmt -> nonlocal NAME , NAME;
assert_stmt -> assert test | assert test , test;
compound_stmt -> if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt;
async_stmt -> ASYNC funcdef | ASYNC with_stmt | ASYNC for_stmt;
if_stmt -> if test : suite | if test : suite A | if test : suite A else : suite;
A -> elif test : suite | elif test : suite A;
while_stmt -> while test : suite | while test : suite else : suite;
for_stmt -> for exprlist in testlist : suite | for exprlist in testlist : suite else : suite;
try_stmt -> try : suite except_clause : suite B | try : suite finally : suite;
B -> else : suite | finally : suite | else : suite finally : suite;
with_stmt -> with with_item C : suite;
C -> , with_item | , with_item C;
with_item -> test | test as expr;
except_clause -> except | except test | except test as NAME;
suite -> simple_stmt | NEWLINE INDENT stmt DEDENT;
test -> or_test | or_test if or_test else test | lambdef;
test_nocond -> or_test | lambdef_nocond;
lambdef -> lambda : test | lambda varargslist : test;
lambdef_nocond -> lambda : test_nocond | lambda varargslist : test_nocond;
or_test -> and_test D;
D -> or and_test | or and_test D
and_test -> not_test E;
E -> and not_test | and not_test E
not_test -> not not_test | comparison;
comparison -> expr (comp_op expr)*;
comp_op -> < | > | == | >= | <= | <> | != | in | not in | is | is not;
star_expr -> * expr;
expr -> xor_expr F;
F -> | xor_expr | | xor_expr F;
xor_expr -> and_expr G;
G -> ^ and_expr | ^ and_expr G;
and_expr -> shift_expr H;
H -> & shift_expr | & shift_expr H;
shift_expr -> arith_expr E2;
E2 -> F2 arith_expr | F2 arith_expr E2;
F2 -> << | >>;
arith_expr: term I;
I -> J term | J term I
J -> + | -
term -> factor S;
S -> T factor | T factor S;
T -> * | @ | / | % | //;
K -> * factor | @ factor | / factor | % factor | // factor;
factor -> + factor | - factor | ~ factor | power;
power -> atom_expr | atom_expr ** factor;
atom_expr -> atom L | AWAIT atom L;
L -> trailer | trailer L;
atom -> ( U ) | [ V ] | { W } | NAME | NUMBER | STRING | ... | None | True | False;
U -> yield_expr | testlist_comp | e;
V -> testlist_comp | e;
W -> dictorsetmaker | e;
testlist_comp -> R U1;
T1 -> , R | , R T1;
U1 -> comp_for | Q1 | Q1 ,;
trailer: ( B1 ) | [ subscriptlist ] | . NAME;
subscriptlist -> subscript F1 | subscript F1 ,;
F1 -> , subscript | , subscript F1
subscript: test | G1 : G1 H1;
G1 -> test | e;
H1 -> sliceop | e;
sliceop -> : G1;
exprlist -> R X | R X ,;
X -> , Y | X;
Y -> expr | star_expr;
testlist -> test Z | test Z ,;
Z -> , test | , test Z
dictorsetmaker: R1 | R S1;
N1 -> test : test | ** expr;
O1 -> , P1 | , P1 O1;
P1 -> test : test | ** expr;
Q1 -> , R | , R Q1;
R1 -> N1 S1 | N1 S1;
S1 -> comp_for | O1 | O1 ,;
classdef -> class NAME A1 : suite;
A1 -> ( B1 ) | e;
B1 -> arglist | e;
arglist -> argument C1 | argument C1 ,;
C1 -> , argument | , argument C1;
argument -> test | test comp_for | test = test | ** test | * test;
comp_iter -> comp_for | comp_if;
comp_for -> D1 for exprlist in or_test E1;
D1 -> ASYNC | e;
E1 -> comp_iter | e
comp_if -> if test_nocond I1;
I1 -> comp_iter | e
encoding_decl -> NAME;
yield_expr -> yield | yield yield_arg;
yield_arg -> from test | testlist;
DEF : def;
RETURN -> return;
RAISE -> raise;
FROM -> from;
IMPORT -> import;
AS -> as;
GLOBAL -> global;
NONLOCAL -> nonlocal;
ASSERT -> assert;
IF -> if;
ELIF -> elif;
ELSE -> else;
WHILE -> while;
FOR -> for;
IN -> in;
TRY -> try;
FINALLY -> finally;
WITH -> with;
EXCEPT -> except;
LAMBDA -> lambda;
OR -> or;
AND -> and;
NOT -> not;
IS -> is;
NONE -> None;
TRUE -> True;
FALSE -> False;
CLASS -> class;
YIELD -> yield;
DEL -> del;
PASS -> pass;
CONTINUE -> continue;
BREAK -> break;
ASYNC -> async;
AWAIT -> await;
DOT -> .;
ELLIPSIS -> ...;
STAR -> *;
OPEN_PAREN -> (;
CLOSE_PAREN -> );
COMMA -> ,;
COLON -> :;
SEMI_COLON -> ;;
POWER -> **;
ASSIGN -> =;
OPEN_BRACK -> [;
CLOSE_BRACK -> ];
OR_OP -> |;
XOR -> ^;
AND_OP -> &;
LEFT_SHIFT -> <<;
RIGHT_SHIFT -> >>;
ADD -> +;
MINUS -> -;
DIV -> /;
MOD -> %;
IDIV -> //;
NOT_OP -> ~;
OPEN_BRACE -> {;
CLOSE_BRACE -> };
LESS_THAN -> <;
GREATER_THAN : >;
EQUALS -> ==;
GT_EQ -> >=;
LT_EQ -> <=;
NOT_EQ_1 -> <>;
NOT_EQ_2 -> !=;
AT -> @;
ARROW -> ->;
ADD_ASSIGN -> +=;
SUB_ASSIGN -> -=;
MULT_ASSIGN -> *=;
AT_ASSIGN -> @=;
DIV_ASSIGN -> /=;
MOD_ASSIGN -> %=;
AND_ASSIGN -> &=;
OR_ASSIGN -> |=;
XOR_ASSIGN -> ^=;
LEFT_SHIFT_ASSIGN -> <<=;
RIGHT_SHIFT_ASSIGN -> >>=;
POWER_ASSIGN -> **=;
IDIV_ASSIGN -> //=;