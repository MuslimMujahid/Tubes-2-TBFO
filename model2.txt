Terminals:
UNKNOWN ENDL with as None continue break pass True true def while False false in range for import not from return : if . + - * / < > <= >= == and or = elif else ( ) [ ] , ' " { }
Variables:
START for_body OPEN_CURL CLOSE_CURL TRUE QUOTE DOUBLE_QUOTE WITH CONTINUE BREAK PASS AS with_stmt with_stmt with_body FALSE DEF def_stmt def_body OPEN_BRAC CLOSE_BRAC DOT WHILE NONE while_stmt while_head while_body VALUE test_not ARRAY NOT loop_name call_func loop_value IN RANGE for_head for_stmt IMPORT FROM NAME NEWLINE if_body OPEN_BRACE CLOSE_BRACE elif_stmt if_head ELIF ELSE else_stmt return_thing import_stmt and_or from_name stmt if_stmt COLON return_stmt IF RETURN if_expr expr operation OP COMPARISON_OP ASSIGN AND OR comparison RETURN NUMBER assignment
Productions:
START -> stmt;
stmt -> import_stmt | if_stmt | if_stmt NEWLINE stmt | assignment | assignment NEWLINE stmt | for_stmt | for_stmt NEWLINE stmt | call_func | call_func NEWLINE stmt | NEWLINE stmt;
stmt -> while_stmt | while_stmt NEWLINE stmt | with_stmt | with_stmt NEWLINE stmt | return_stmt | def_stmt;
if_stmt -> IF if_head if_body | IF if_head if_body elif_stmt | IF if_head if_body else_stmt | IF if_head if_body elif_stmt else_stmt;
if_head -> expr COLON | OPEN_BRACE expr CLOSE_BRACE;
if_body -> NEWLINE stmt;
elif_stmt -> NEWLINE ELIF if_head if_body | NEWLINE ELIF if_head if_body elif_stmt;
else_stmt -> NEWLINE ELSE COLON if_body;
expr -> VALUE | comparison | VALUE and_or expr | comparison and_or expr | OPEN_BRACE expr CLOSE_BRACE;
and_or -> AND | OR;
operation -> NAME OP NAME | NAME OP operation;
assignment -> NAME ASSIGN expr | NAME ASSIGN VALUE;
comparison -> VALUE COMPARISON_OP VALUE | NAME COMPARISON_OP VALUE and_or comparison;
comparison -> VALUE test_not IN VALUE | NOT OPEN_BRACE comparison CLOSE_BRACE | OPEN_BRACE comparison CLOSE_BRACE;
test_not -> e | NOT;
return_stmt -> RETURN return_thing | CONTINUE | BREAK | PASS;
return_thing -> VALUE | expr | comparison;
import_stmt -> from_name IMPORT NAME | from_name IMPORT NAME NEWLINE import_stmt;
from_name -> e | FROM NAME | FROM NAME from_name;
for_stmt -> FOR for_head for_body;
for_head -> NAME IN RANGE OPEN_BRACE loop_name CLOSE_BRACE COLON | VALUE IN VALUE COLON;
for_body -> NEWLINE stmt;
loop_name -> NAME | NAME COMMA loop_name;
while_stmt -> WHILE while_head while_body;
while_head -> expr COLON | OPEN_BRACE expr CLOSE_BRACE COLON;
while_body -> NEWLINE stmt;
VALUE -> TRUE | FALSE | NONE | loop_name | operation | call_func | OPEN_BRACE VALUE CLOSE_BRACE | NAME OPEN_BRAC VALUE CLOSE_BRAC | ARRAY;
call_func -> NAME OPEN_BRACE VALUE CLOSE_BRACE | NAME OPEN_BRACE CLOSE_BRACE | VALUE DOT call_func;
loop_value -> VALUE | VALUE COMMA loop_name;
def_stmt -> DEF NAME OPEN_BRACE loop_name CLOSE_BRACE COLON def_body | DEF NAME OPEN_BRACE CLOSE_BRACE COLON def_body; 
def_body -> NEWLINE stmt; 
with_stmt -> WITH with_head with_body;
with_head -> VALUE AS VALUE COLON;
with_body -> NEWLINE stmt;
ARRAY -> VALUE | OPEN_BRAC loop_value CLOSE_BRAC | OPEN_BRAC CLOSE_BRAC | OPEN_CURL loop_value CLOSE_CURL | OPEN_CURL CLOSE_CURL;
WITH -> with;
AS -> as;
DEF -> def;
NONE -> None;
WHILE -> while;
NOT -> not;
IN -> in;
RANGE -> range;
FOR -> for;
AND -> and;
OR -> or;
IMPORT -> import;
FROM -> from;
NAME -> UNKNOWN;
NEWLINE -> ENDL;
COLON -> :;
RETURN -> return;
OP -> + | - | * | / ;
COMPARISON_OP -> < | > | <= | >= | ==;
ASSIGN -> =;
NUMBER -> NAME;
IF -> if;
ELIF -> elif;
ELSE -> else;
OPEN_BRAC -> [;
CLOSE_BRAC -> ];
OPEN_BRACE -> (;
CLOSE_BRACE -> );
COMMA -> ,;
TRUE -> True | true;
FALSE -> False | false;
DOT -> .;
NAME -> QUOTE NAME QUOTE | DOUBLE_QUOTE NAME DOUBLE_QUOTE | NAME DOT NAME | DOUBLE_QUOTE DOUBLE_QUOTE | QUOTE QUOTE;
CONTINUE -> continue;
BREAK -> break;
PASS -> pass;
QUOTE -> ';
DOUBLE_QUOTE -> ";
OPEN_CURL -> {;
CLOSE_CURL -> }
