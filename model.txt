Terminals:
def : NAME NEWLINE ( ) * ** = ,  += -= *= @= /= %= &= |= ^= <<= >>= **= //= del pass break continue return raise import from . ... as global nonlocal assert decorated if else elif while for in try finally with except INDENT DEDENT lambda or and not < > == >= <= <> != is ^ & << >> + - @ / % // ~ [ ] { } NUMBER STRING None True False class yield async await ->
Variables:
START single_input async_funcdef funcdef parameters V1 SEMI_COLON typedargslist W1 X1 Y1 Z1 A2 B2 C2 D2 tfpdef varargslist G2 H2 I2 J2 K2 L2 M2 vfpdef stmt simple_stmt M small_stmt expr_stmt P N O annassign testlist_star_expr Q R augassign del_stmt pass_stmt flow_stmt break_stmt continue_stmt return_stmt yield_stmt raise_stmt import_stmt import_name import_from J1 K1 L1 M1 import_as_name dotted_as_name import_as_names dotted_as_names dotted_name global_stmt nonlocal_stmt assert_stmt compound_stmt async_stmt if_stmt A while_stmt for_stmt try_stmt B with_stmt C with_item except_clause suite test test_nocond lambdef lambdef_nocond or_test D and_test E not_test comparison N2 comp_op expr | N2; comp_op star_expr expr F xor_expr G and_expr H shift_expr E2 F2 arith_expr I J term S T K factor power atom_expr L atom U V W testlist_comp T1 U1 trailer subscriptlist F1 subscript G1 H1 sliceop exprlist X Y testlist Z dictorsetmaker N1 O1 P1 Q1 R1 S1 classdef A1 B1 arglist C1 argument comp_iter comp_for D1 E1 comp_if I1 encoding_decl yield_expr yield_arg DEF RETURN RAISE FROM IMPORT AS GLOBAL NONLOCAL ASSERT IF ELIF ELSE WHILE FOR IN TRY FINALLY WITH EXCEPT LAMBDA OR AND NOT IS NONE TRUE FALSE CLASS YIELD DEL PASS CONTINUE BREAK ASYNC AWAIT DOT ELLIPSIS STAR OPEN_PAREN CLOSE_PAREN COMMA COLON POWER ASSIGN OPEN_BRACK CLOSE_BRACK OR_OP XOR AND_OP LEFT_SHIFT RIGHT_SHIFT ADD MINUS DIV MOD IDIV NOT_OP OPEN_BRACE CLOSE_BRACE LESS_THAN GREATER_THAN EQUALS GT_EQ LT_EQ NOT_EQ_1 NOT_EQ_2 AT ARROW ADD_ASSIGN SUB_ASSIGN MULT_ASSIGN AT_ASSIGN DIV_ASSIGN MOD_ASSIGN AND_ASSIGN OR_ASSIGN XOR_ASSIGN LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN POWER_ASSIGN IDIV_ASSIGN
Productions:
START -> single_input | single_input START
single_input -> NEWLINE | simple_stmt | compound_stmt NEWLINE;
async_funcdef -> ASYNC funcdef;
funcdef -> DEF NAME parameters COLON suite;
parameters -> OPEN_PAREN V1 CLOSE_PAREN;
V1 -> typedargslist | e;
typedargslist -> W1 X1 B2 | STAR D2 X1 B2 | POWER tfpdef A2;
W1 -> tfpdef | tfpdef ASSIGN test;
X1 -> COMMA W1 | COMMA W1 X1;
Y1 -> COMMA Z1 | e;
Z1 -> POWER tfpdef A2 | e;
A2 -> COMMA | e;
B2 -> COMMA C2 | e;
C2 -> STAR X1 Y1 | POWER tfpdef A2 | STAR tfpdef X1 Y1 | e;
D2 -> tfpdef | e;
tfpdef -> NAME;
varargslist -> vfpdef G2 H2 J2 | STAR L2 H2 M2 | POWER vfpdef A2;
G2 -> ASSIGN test | e;
H2 -> COMMA vfpdef G2 | COMMA vfpdef G2 H2;
I2 -> POWER vfpdef A2 | e;
J2 -> COMMA K2 | e;
K2 -> STAR L2 H2 M2 | POWER vfpdef A2 | e;
L2 -> vfpdef | e;
M2 -> COMMA I2 | e;
vfpdef -> NAME;
stmt -> simple_stmt | compound_stmt;
simple_stmt -> small_stmt M NEWLINE | small_stmt M SEMI_COLON NEWLINE;
M -> SEMI_COLON small_stmt | SEME_COLON small_stmt M;
small_stmt -> expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt;
expr_stmt -> testlist_star_expr annassign | testlist_star_expr augassign P | testlist_star_expr N;
P -> yield_expr | testlist;
N -> ASSIGN O | ASSIGN O N;
O -> yield_expr | testlist_star_expr;
annassign -> COLON test | COLON test = test;
testlist_star_expr -> R Q | R Q COMMA;
Q -> COMMA R | COMMA R Q;
R -> test | star_expr;
augassign -> ADD_ASSIGN | SUB_ASSIGN | MULT_ASSIGN | AT_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | AND_ASSIGN | OR_ASSIGN | POWER_ASSIGN | LEFT_SHIFT_ASSIGN | RIGHT_SHIFT_ASSIGN | POWER_ASSIGN | IDIV_ASSIGN;
del_stmt -> DEL exprlist;
pass_stmt -> PASS;
flow_stmt -> break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt;
break_stmt -> BREAK;
continue_stmt -> CONTINUE;
return_stmt -> RETURN;
yield_stmt -> yield_expr;
raise_stmt -> RAISE;
import_stmt -> import_name | import_from;
import_name -> import dotted_as_names;
import_from -> FROM L1 IMPORT M1;
J1 -> K1 | K1 J1;
K1 -> DOT | ELLIPSIS;
L1 -> J1 dotted_name | K1;
M1 -> STAR | OPEN_PAREN import_as_names CLOSE_PAREN | import_as_names;
import_as_name -> NAME | NAME AS NAME;
dotted_as_name -> dotted_name | dotted_name AS NAME;
import_as_names -> import_as_name | COMMA import_as_name;
dotted_as_names -> dotted_as_name | COMMA dotted_as_name;
dotted_name -> NAME | DOT NAME;
global_stmt -> GLOBAL NAME | GLOBAL NAME COMMA NAME;
nonlocal_stmt -> NONLOCAL NAME COMMA NAME;
assert_stmt -> ASSERT test | ASSERT test COMMA test;
compound_stmt -> if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt;
async_stmt -> ASYNC funcdef | ASYNC with_stmt | ASYNC for_stmt;
if_stmt -> IF test COLON suite | IF test COLON suite A | IF test COLON suite A ELSE COLON suite;
A -> ELIF test COLON suite | ELIF test COLON suite A;
while_stmt -> WHILE test COLON suite | WHILE test COLON suite ELSE COLON suite;
for_stmt -> FOR exprlist IN testlist COLON suite | FOR exprlist IN testlist COLON suite ELSE COLON suite;
try_stmt -> TRY COLON suite except_clause COLON suite B | TRY COLON suite FINALLY COLON suite;
B -> ELSE COLON suite | FINALLY COLON suite | ELSE COLON suite FINALLY COLON suite;
with_stmt -> with with_item C COLON suite;
C -> COMMA with_item | COMMA with_item C;
with_item -> test | test AS expr;
except_clause -> EXCEPT | EXCEPT test | EXCEPT test AS NAME;
suite -> simple_stmt | NEWLINE INDENT stmt DEDENT;
test -> or_test | or_test IF or_test ELSE test | lambdef;
test_nocond -> or_test | lambdef_nocond;
lambdef -> LAMBDA COLON test | LAMBDA varargslist COLON test;
lambdef_nocond -> LAMBDA COLON test_nocond | LAMBDA varargslist COLON test_nocond;
or_test -> and_test D;
D -> OR and_test | OR and_test D;
and_test -> not_test E;
E -> AND not_test | and not_test E;
not_test -> NOT NAME | NOT NAME not_test | NOT not_test | comparison;
comparison -> expr N2;
N2 -> comp_op expr | N2;
comp_op -> LESS_THAN | GREATER_THAN | EQUALS | GT_EQ | LT_EQ | NOT_EQ_1 | NOT_EQ_2 | IN | NOT IN | IS | IS NOT;
star_expr -> STAR expr;
expr -> xor_expr F;
F -> | xor_expr | | xor_expr F;
xor_expr -> and_expr G;
G -> XOR and_expr | XOR and_expr G;
and_expr -> shift_expr H;
H -> AND_OP shift_expr | AND_OP shift_expr H;
shift_expr -> arith_expr E2;
E2 -> F2 arith_expr | F2 arith_expr E2;
F2 -> LEFT_SHIFT | RIGHT_SHIFT;
M1 -> STAR | OPEN_PAREN import_as_names CLOSE_PAREN | import_as_names;
import_as_name -> NAME | NAME AS NAME;
dotted_as_name -> dotted_name | dotted_name AS NAME;
import_as_names -> import_as_name | COMMA import_as_name;
dotted_as_names -> dotted_as_name | COMMA dotted_as_name;
dotted_name -> NAME | DOT NAME;
global_stmt -> GLOBAL NAME | GLOBAL NAME COMMA NAME;
nonlocal_stmt -> NONLOCAL NAME COMMA NAME;
assert_stmt -> ASSERT test | ASSERT test COMMA test;
compound_stmt -> if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt;
async_stmt -> ASYNC funcdef | ASYNC with_stmt | ASYNC for_stmt;
if_stmt -> IF test COLON suite | IF test COLON suite A | IF test COLON suite A ELSE COLON suite;
A -> ELIF test COLON suite | ELIF test COLON suite A;
while_stmt -> WHILE test COLON suite |
arith_expr -> term I;
I -> J term | J term I;
J -> ADD | MINUS;
term -> factor S;
S -> T factor | T factor S;
T -> STAR | AT | DIV | MOD | IDIV;
K -> STAR factor | AT factor | DIV factor | MOD factor | IDIV factor;
factor -> ADD factor | MINUS factor | NOT_OP factor | power;
power -> atom_expr | atom_expr POWER factor;
atom_expr -> atom L | AWAIT atom L;
L -> trailer | trailer L;
atom -> OPEN_PAREN U CLOSE_PAREN | OPEN_BRACK V CLOSE_BRACK | OPEN_BRACE W CLOSE_BRACE | NAME | NUMBER | STRING | ELLIPSIS | NONE | TRUE | FALSE;
U -> yield_expr | testlist_comp | e;
V -> testlist_comp | e;
W -> dictorsetmaker | e;
testlist_comp -> R U1;
T1 -> COMMA R | COMMA R T1;
U1 -> comp_for | Q1 | Q1 COMMA;
trailer -> OPEN_PAREN B1 CLOSE_PAREN | OPEN_BRACK subscriptlist CLOSE_BRACK | DOT NAME;
subscriptlist -> subscript F1 | subscript F1 COMMA;
F1 -> COMMA subscript | COMMA subscript F1;
subscript -> test | G1 COLON G1 H1;
G1 -> test | e;
H1 -> sliceop | e;
sliceop -> COLON G1;
exprlist -> R X | R X COMMA;
X -> COMMA Y | X;
Y -> expr | star_expr;
testlist -> test Z | test Z COMMA;
Z -> COMMA test | COMMA test Z;
dictorsetmaker -> R1 | R S1;
N1 -> test COLON test | POWER expr;
O1 -> COMMA P1 | COMMA P1 O1;
P1 -> test COLON test | POWER expr;
Q1 -> COMMA R | COMMA R Q1;
R1 -> N1 S1 | N1 S1;
S1 -> comp_for | O1 | O1 COMMA;
classdef -> CLAS NAME A1 COLON suite;
A1 -> OPEN_PAREN B1 CLOSE_PAREN | e;
B1 -> arglist | e;
arglist -> argument C1 | argument C1 COMMA;
C1 -> COMMA argument | COMMA argument C1;
argument -> test | test comp_for | test ASSIGN test | POWER test | STAR test;
comp_iter -> comp_for | comp_if;
comp_for -> D1 FOR exprlist IN or_test E1;
D1 -> ASYNC | e;
E1 -> comp_iter | e;
comp_if -> IF test_nocond I1;
I1 -> comp_iter | e;
encoding_decl -> NAME;
yield_expr -> YIELD | YIELD yield_arg;
yield_arg -> FROM test | testlist;
DEF -> def;
RETURN -> return;
RAISE -> raise;
FROM -> from;
IMPORT -> import;
AS -> as;
GLOBAL -> global;
NONLOCAL -> nonlocal;
ASSERT -> assert;
IF -> if;
ELIF -> elif;
ELSE -> else;
WHILE -> while;
FOR -> for;
IN -> in;
TRY -> try;
FINALLY -> finally;
WITH -> with;
EXCEPT -> except;
LAMBDA -> lambda;
OR -> or;
AND -> and;
NOT -> not;
IS -> is;
NONE -> None;
TRUE -> True;
FALSE -> False;
CLASS -> class;
YIELD -> yield;
DEL -> del;
PASS -> pass;
CONTINUE -> continue;
BREAK -> break;
ASYNC -> async;
AWAIT -> await;
DOT -> .;
ELLIPSIS -> ...;
STAR -> *;
OPEN_PAREN -> (;
CLOSE_PAREN -> );
COMMA -> ,;
COLON -> :;
POWER -> **;
ASSIGN -> =;
OPEN_BRACK -> [;
CLOSE_BRACK -> ];
OR_OP -> |;
XOR -> ^;
AND_OP -> &;
LEFT_SHIFT -> <<;
RIGHT_SHIFT -> >>;
ADD -> +;
MINUS -> -;
DIV -> /;
MOD -> %;
IDIV -> //;
NOT_OP -> ~;
OPEN_BRACE -> {;
CLOSE_BRACE -> };
LESS_THAN -> <;
GREATER_THAN -> >;
EQUALS -> ==;
GT_EQ -> >=;
LT_EQ -> <=;
NOT_EQ_1 -> <>;
NOT_EQ_2 -> !=;
AT -> @;
ARROW -> ->;
ADD_ASSIGN -> +=;
SUB_ASSIGN -> -=;
MULT_ASSIGN -> *=;
AT_ASSIGN -> @=;
DIV_ASSIGN -> /=;
MOD_ASSIGN -> %=;
AND_ASSIGN -> &=;
OR_ASSIGN -> |=;
XOR_ASSIGN -> ^=;
LEFT_SHIFT_ASSIGN -> <<=;
RIGHT_SHIFT_ASSIGN -> >>=;
POWER_ASSIGN -> **=;
IDIV_ASSIGN -> //=;
SEMI_COLON -> Temp
